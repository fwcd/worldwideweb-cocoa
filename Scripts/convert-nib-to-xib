#!/usr/bin/env python3

# A small tool to convert a legacy NeXTStep NIB bundle to a modern Interface
# Builder XIB that recent versions of Xcode (e.g. 15.4) can read. Note that
# the tool cannot handle many of the newer versions of the NIB file format
# and is expressly built to handle the reverse engineered WorldWideWeb.nib

from dataclasses import dataclass
from pathlib import Path
from uuid import uuid4
from typing import Any, Optional, Self

import argparse
import typedstream
import xml.etree.ElementTree as ET

next_object_id = 0

class XIBNode:
    def __init__(self, element: ET.Element, id: Optional[str]=None, custom_class: Optional[str]=None):
        self.element = element
        self.id = id
        self.custom_class = custom_class

        self._connections: Optional[Self] = None
        self._items: Optional[Self] = None
        self._subviews: Optional[Self] = None
        self._cells: Optional[Self] = None
        self._column: Optional[Self] = None
        self._attributes: Optional[Self] = None

    def add_object(self, class_or_tag_name: str, id: Optional[str]=None, **kwargs) -> Self:
        '''Adds an object under this node.'''

        assert len(class_or_tag_name) > 0
        is_custom = class_or_tag_name[0].isupper()

        if not id:
            global next_object_id
            id = str(next_object_id)
            next_object_id += 1

        child = ET.Element('customObject' if is_custom else class_or_tag_name, attrib={
            'id': id,
            **kwargs,
            **({'customClass': class_or_tag_name} if is_custom else {}),
        })
        self.element.append(child)

        return XIBNode(child, id=id, custom_class=class_or_tag_name if is_custom else None)
    
    def add(self, tag_name: str, **kwargs) -> Self:
        '''Adds a custom node under this node.'''

        child = ET.Element(tag_name, attrib={**kwargs})
        self.element.append(child)

        return XIBNode(child)
    
    def add_menu_item(self, **kwargs) -> Self:
        '''Adds a menu item to this menu.'''

        items = self if self.element.tag == 'items' else self.items
        return items.add_object('menuItem', **kwargs)

    def add_submenu(self, **kwargs) -> Self:
        '''Adds a submenu to this menu.'''

        assert self.element.tag == 'menuItem', 'Can only add a submenu to a menu item'
        return self.add_object('menu', key='submenu', title=self.element.attrib['title'], **kwargs)
    
    def __str__(self):
        return self.custom_class or self.element.tag

    @property
    def connections(self) -> Self:
        assert self.id is not None, 'Can only connect to an object with an id'
        if self._connections is None:
            self._connections = XIBNode(ET.Element('connections'))
            self.element.append(self._connections.element)
        return self._connections

    @property
    def items(self) -> Self:
        assert self.element.tag == 'menu', 'Can only fetch items on a menu (object)'
        if self._items is None:
            self._items = XIBNode(ET.Element('items'))
            self.element.append(self._items.element)
        return self._items

    @property
    def subviews(self) -> Self:
        if self._subviews is None:
            self._subviews = XIBNode(ET.Element('subviews'))
            self.element.append(self._subviews.element)
        return self._subviews

    @property
    def cells(self) -> Self:
        if self._cells is None:
            self._cells = XIBNode(ET.Element('cells'))
            self.element.append(self._cells.element)
        return self._cells

    @property
    def column(self) -> Self:
        if self._column is None:
            self._column = XIBNode(ET.Element('column'))
            self.element.append(self._column.element)
        return self._column

    @property
    def attributes(self) -> Self:
        if self._attributes is None:
            self._attributes = XIBNode(ET.Element('attributes'))
            self.element.append(self._attributes.element)
        return self._attributes

    def connect_outlet(self, property: str, destination: str | Self):
        '''Adds an outlet to the given destination.'''

        return self.connections.add_object('outlet',
            property=property,
            destination=destination if isinstance(destination, str) else destination.id,
        )
    
    def connect_action(self, selector: str, target: str | Self):
        '''Adds an action invoking the given target with the given selector.'''

        return self.connections.add_object('action',
            selector=selector,
            target=target if isinstance(target, str) else target.id,
        )
    
class XIB:
    def __init__(self):
        self.root = ET.Element('document', attrib={
            'type': 'com.apple.InterfaceBuilder3.Cocoa.XIB',
            'version': '3.0',
            'toolsVersion': '32700.99.1234',
            'targetRuntime': 'MacOSX.Cocoa',
            'propertyAccessControl': 'none',
            'useAutolayout': 'NO',
            'customObjectInstantiationMethod': 'direct',
        })

        self.tree = ET.ElementTree(self.root)
    
        self.dependencies = self.add_node('dependencies')
        self.dependencies.add('plugIn', identifier='com.apple.InterfaceBuilder.CocoaPlugin', version='22690')
        self.dependencies.add('capability', name='documents saved in the Xcode 8 format', minToolsVersion='8.0')

        self.objects = self.add_node('objects')
        self.resources = self.add_node('resources')

        # Add default objects
        self.files_owner = self.objects.add_object('NSApplication', id='-2', userLabel="File's Owner")
        self.first_responder = self.objects.add_object('FirstResponder', id='-1', userLabel='First Responder')
        self.objects.add_object('NSObject', id='-3', userLabel='Application')
        self.font_manager = self.objects.add_object('NSFontManager')

        # Add main menu
        main_menu = self.objects.add_object('menu', systemMenu='main')
        main_menu.add('point', key='canvasLocation', x='200', y='121')

        app_item = main_menu.add_menu_item(title='WorldWideWeb')
        app_menu = app_item.add_submenu(systemMenu='apple')
        app_menu.add_menu_item(title='About WorldWideWeb')
        app_menu.add_menu_item(isSeparatorItem='YES')

        self.main_menu = main_menu
        self.app_menu = app_menu

    def add_node(self, name: str) -> XIBNode:
        '''Creates a new node under the document root.'''

        element = ET.Element(name)
        self.root.append(element)
        return XIBNode(element)

    def indent(self, indent: str=' ' * 4):
        '''Indents the tree with the given indent (4 spaces by default).'''

        ET.indent(self.tree, space=indent)
    
    def write(self, path: Path):
        '''Writes the XIB to the given path.'''

        self.tree.write(path, encoding='utf-8', xml_declaration=True)

@dataclass
class Options:
    pass

class XIBConverter:
    def __init__(self, options: Options):
        self.options = options
        self.xib = XIB()

        self.visited_objects: set[typedstream.GenericArchivedObject] = set()
        self.object_to_xib_node: dict[typedstream.GenericArchivedObject, XIBNode] = {}
        self.registered_images: set[str] = set()
    
    def traverse_menu_cell(self, cell: typedstream.GenericArchivedObject, xib_menu: XIBNode, level: int):
        '''Traverses the given NIB menu cell and adds it to the given XIB menu.'''

        assert cell.clazz.name == b'MenuCell', cell.clazz.name

        # Parse basic metadata
        title = cell.contents[0].values[0].decode()

        xib_properties = {}

        # Parse the key equivalent/keyboard shortcut
        shortcut_info = cell.contents[4]
        if len(shortcut_info.values) == 4 and isinstance(shortcut_info.values[3], int):
            key_equivalent = shortcut_info.values[3] >> 8
            if key_equivalent > 0:
                xib_properties['keyEquivalent'] = chr(key_equivalent)

        # Parse the submenu
        submenu = cell.contents[1].values[0]
        has_submenu = isinstance(submenu, typedstream.GenericArchivedObject) and submenu.clazz.name == b'MenuTemplate'

        # Avoid adding menu items or special menus (e.g. Services) to the menu
        # bar directly to match the macOS conventions.
        if (not has_submenu or title in {'Services'}) and xib_menu == self.xib.main_menu:
            xib_item = self.xib.app_menu.add_menu_item(title=title, **xib_properties)
        else:
            xib_item = xib_menu.add_menu_item(title=title, **xib_properties)
        
        self.object_to_xib_node[cell] = xib_item

        if has_submenu:
            xib_submenu = xib_item.add_submenu()
            self.traverse_menu(submenu, xib_submenu, level=level)
        else:
            print(f"{'  ' * level}{title}")

    def traverse_menu(self, menu: typedstream.GenericArchivedObject, xib_menu: XIBNode, level: int=0):
        '''Traverses the given NIB menu and adds its cells to the given XIB menu.'''

        assert menu.clazz.name == b'MenuTemplate', menu.clazz.name

        self.object_to_xib_node[menu] = xib_menu

        # Parse basic metadata
        title = menu.contents[2].values[0].decode()

        # Output an indented short description for debugging
        print(f"{'  ' * level}{title} @ {id(menu)}")

        # Parse the matrix
        matrix = menu.contents[2].values[1]
        assert isinstance(matrix, typedstream.GenericArchivedObject) and matrix.clazz.name == b'Matrix'

        # Parse the list holding the cells from the matrix
        matrix_list = matrix.contents[12].values[0]
        assert isinstance(matrix_list, typedstream.types.nextstep.List), type(matrix_list)

        # Convert the menu cells to XIB items
        for cell in matrix_list.elements:
            assert isinstance(cell, typedstream.GenericArchivedObject)
            self.traverse_menu_cell(cell, xib_menu, level=level + 1)

    def traverse_main_menu(self, menu: typedstream.GenericArchivedObject):
        '''Traverses the given NIB main menu and adds its cells to the XIB main menu.'''

        self.traverse_menu(menu, self.xib.main_menu)

    def traverse_custom_object(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB custom object and adds it to the XIB.'''

        assert obj.clazz.name == b'CustomObject', obj.clazz.name

        custom_class = obj.contents[0].values[0].decode()
        match custom_class:
            case 'Application':
                self.object_to_xib_node[obj] = self.xib.files_owner
            case 'FontManager':
                self.object_to_xib_node[obj] = self.xib.font_manager
            case _:
                print(f'Adding custom object {custom_class}')
                self.object_to_xib_node[obj] = self.xib.objects.add_object(custom_class)

    def traverse_control_connector(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB control connector and adds it to the XIB.'''

        assert obj.clazz.name == b'IBControlConnector', obj.clazz.name

        group = obj.contents[0]
        src_obj = group.values[0]
        dest_obj = group.values[1]
        selector = group.values[2].decode()

        # Not sure why this can happen, but apparently it can
        if dest_obj is None:
            return

        if src_xib_node := self.object_to_xib_node.get(src_obj):
            if dest_xib_node := self.object_to_xib_node.get(dest_obj):
                print(f'Connecting {src_xib_node} to {selector} on {dest_xib_node} (action)')
                src_xib_node.connect_action(
                    selector=selector,
                    target=dest_xib_node,
                )
            else:
                print(f'Warning: Could not connect action due to untranslated destination object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')
        else:
            print(f'Warning: Could not connect action due to untranslated source object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')

    def traverse_outlet_connector(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB outlet connector and adds it to the XIB.'''

        assert obj.clazz.name == b'IBOutletConnector', obj.clazz.name

        group = obj.contents[0]
        src_obj = group.values[0]
        dest_obj = group.values[1]
        property = group.values[2].decode()

        if src_xib_node := self.object_to_xib_node.get(src_obj):
            if dest_xib_node := self.object_to_xib_node.get(dest_obj):
                print(f"Connecting {src_xib_node}'s {property} to {dest_xib_node} (outlet)")
                src_xib_node.connect_outlet(
                    property=property,
                    destination=dest_xib_node,
                )
            else:
                print(f'Warning: Could not connect outlet due to untranslated destination object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')
        else:
            print(f'Warning: Could not connect outlet due to untranslated source object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')

    def convert_rect(self, group: typedstream.TypedGroup) -> dict[str, str]:
        return {
            'x': str(group.values[0]),
            'y': str(group.values[1]),
            'width': str(group.values[2]),
            'height': str(group.values[3]),
        }
    
    def convert_size(self, group: typedstream.TypedGroup) -> dict[str, str]:
        return {
            'width': str(group.values[0]),
            'height': str(group.values[1]),
        }
    
    def convert_image_name(self, nx_name: str) -> Optional[str]:
        '''Maps the given NeXTStep image name to an SF Symbol.'''

        catalog = 'system'

        match nx_name:
            case 'NXreturnSign':
                name = 'return'
                width = 17
                height = 14
            case _:
                print(f'Warning: Image name {nx_name} could not be converted')
                return None
        
        if name not in self.registered_images:
            self.registered_images.add(name)
            self.xib.resources.add('image', name=name, catalog=catalog, width=str(width), height=str(height))

        return {
            'image': name,
            'catalog': catalog,
        }

    # TODO: Abstract over more commonalities between the different view types

    def traverse_view(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB view and adds it to the XIB.'''
        
        assert obj.clazz.name == b'View', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        children = obj.contents[6].values[0]

        xib_view = xib_parent.add_object('view', **kwargs)
        xib_view.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_view

        if children is not None:
            assert isinstance(children, typedstream.types.nextstep.List)
            for child in children.elements:
                assert isinstance(child, typedstream.GenericArchivedObject), type(child)
                self.traverse_any_view(child, xib_view.subviews)

    def traverse_box(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB box and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Box', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        children = obj.contents[6].values[0]

        xib_box = xib_parent.add_object('box', **kwargs)
        xib_box.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_box

        assert isinstance(children, typedstream.types.nextstep.List)
        content_view = children.elements[0]
        self.traverse_view(content_view, xib_box, key='contentView')

    def traverse_button_cell(self, obj: typedstream.GenericArchivedObject, xib_button: XIBNode):
        '''Traverses the given NIB button cell and adds it to the XIB.'''
        
        assert obj.clazz.name == b'ButtonCell', obj.clazz.name

        title = obj.contents[0].values[0].decode()
        image = obj.contents[5].values[0]

        xib_properties = {}

        if isinstance(image, typedstream.GenericArchivedObject) and image.clazz.name == b'NXImage':
            image_props = self.convert_image_name(image.contents[0].values[1].decode())
            if image_props:
                xib_properties = {
                    **xib_properties,
                    **image_props,
                    'imagePosition': 'right',
                }

        # TODO: Figure out a cleaner looking button style that preserves the intended look and feel
        xib_cell = xib_button.add('buttonCell',
            key='cell',
            title=title,
            type='square',
            bezelStyle='shadowlessSquare',
            borderStyle='border',
            alignment='center',
            **xib_properties,
        )
        self.object_to_xib_node[obj] = xib_cell

    def traverse_button(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB button and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Button', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        cell = obj.contents[7].values[1]

        xib_button = xib_parent.add_object('button', **kwargs)
        xib_button.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_button

        self.traverse_button_cell(cell, xib_button)

    def traverse_text(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB text and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Text', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        raw_contents = obj.contents[15].values[0]
        
        assert isinstance(raw_contents, typedstream.archiving.Array)

        contents = raw_contents.elements.decode()

        xib_text_view = xib_parent.add_object('textView', **kwargs)
        xib_text_view.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_text_view

        # TODO: Translate these (apparently RTF) contents to a proper attributed string
        xib_string = xib_text_view.add('attributedString', key='textStorage')
        xib_fragment = xib_string.add('fragment')
        xib_fragment.attributes.add('color',
            key='NSColor',
            name='textColor',
            catalog='System',
            colorSpace='catalog',
        )

        xib_fragment_string = xib_fragment.add('mutableString', key='content')
        xib_fragment_string.element.text = contents
    
    def traverse_text_field_cell(self, obj: typedstream.GenericArchivedObject, xib_text_field: XIBNode):
        '''Traverses the given NIB text field cell and adds it to the XIB.'''
        
        assert obj.clazz.name == b'TextFieldCell', obj.clazz.name

        title = obj.contents[0].values[0].decode()

        # TODO: Figure out a cleaner looking button style that preserves the intended look and feel
        xib_cell = xib_text_field.add('textFieldCell',
            key='cell',
            title=title,
        )
        xib_cell.add('color',
            key='textColor',
            name='secondaryLabelColor',
            catalog='System',
            colorSpace='catalog',
        )
        self.object_to_xib_node[obj] = xib_cell

    def traverse_text_field(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB text field and adds it to the XIB.'''
        
        assert obj.clazz.name == b'TextField', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        cell = obj.contents[7].values[1]

        xib_text_field = xib_parent.add_object('textField', **kwargs)
        xib_text_field.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_text_field

        self.traverse_text_field_cell(cell, xib_text_field)

    def traverse_form_cell(self, obj: typedstream.GenericArchivedObject, xib_cells: XIBNode):
        '''Traverses the given NIB form cell and adds it to the XIB.'''
        
        assert obj.clazz.name == b'FormCell', obj.clazz.name

        width = obj.contents[3].values[0] # TODO: Is this actually a width? Should we use it?
        cell = obj.contents[3].values[1]

        assert isinstance(cell, typedstream.GenericArchivedObject), type(cell)
        assert cell.clazz.name == b'Cell', cell.clazz.name

        title = cell.contents[0].values[0].decode()

        xib_cell = xib_cells.add_object('formCell',
            title=title,
            selectable='YES',
            editable='YES',
            borderStyle='border',
        )
        self.object_to_xib_node[obj] = xib_cell

    def traverse_form(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB form and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Form', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        cells = obj.contents[12].values[0]
        cell_size = self.convert_size(obj.contents[13])

        xib_form = xib_parent.add_object('form', **kwargs)
        xib_form.add('rect', key='frame', **frame)
        xib_form.add('size', key='cellSize', **cell_size)
        self.object_to_xib_node[obj] = xib_form

        if cells is not None:
            assert isinstance(cells, typedstream.types.nextstep.List)
            for cell in cells.elements:
                assert isinstance(cell, typedstream.GenericArchivedObject), type(cell)
                self.traverse_form_cell(cell, xib_form.cells.column)

    def traverse_clip_view(self, obj: typedstream.GenericArchivedObject, xib_scroll_view: XIBNode, **kwargs):
        '''Traverses the given NIB clip view and adds it to the XIB.'''
        
        assert obj.clazz.name == b'ClipView', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        children = obj.contents[6].values[0]

        xib_clip_view = xib_scroll_view.add_object('clipView', key='contentView')
        xib_clip_view.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_clip_view

        if children is not None:
            assert isinstance(children, typedstream.types.nextstep.List)
            for child in children.elements:
                assert isinstance(child, typedstream.GenericArchivedObject), type(child)
                self.traverse_any_view(child, xib_clip_view.subviews)

    def traverse_scroller(self, obj: typedstream.GenericArchivedObject, xib_scroll_view: XIBNode, **kwargs):
        '''Traverses the given NIB scroller and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Scroller', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])

        # TODO: Are we guaranteed to get vertical scrollers? Currently the only one seems to be in the Info window
        xib_scroller = xib_scroll_view.add_object('scroller', key='verticalScroller')
        xib_scroller.add('rect', key='frame', **frame)

    def traverse_scroll_view(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB scroll view and adds it to the XIB.'''
        
        assert obj.clazz.name == b'ScrollView', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        children = obj.contents[6].values[0]

        assert isinstance(children, typedstream.types.nextstep.List)

        clip_view = children.elements[0]
        scrollers = children.elements[1:]

        xib_scroll_view = xib_parent.add_object('scrollView', **kwargs)
        xib_scroll_view.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_scroll_view

        self.traverse_clip_view(clip_view, xib_scroll_view)
        for scroller in scrollers:
            self.traverse_scroller(scroller, xib_scroll_view)

    def traverse_any_view(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        match obj.clazz.name.decode():
            case 'View':
                self.traverse_view(obj, xib_parent, **kwargs)
            case 'Box':
                self.traverse_box(obj, xib_parent, **kwargs)
            case 'Button':
                self.traverse_button(obj, xib_parent, **kwargs)
            case 'Text':
                self.traverse_text(obj, xib_parent, **kwargs)
            case 'TextField':
                self.traverse_text_field(obj, xib_parent, **kwargs)
            case 'Form':
                self.traverse_form(obj, xib_parent, **kwargs)
            case 'ScrollView':
                self.traverse_scroll_view(obj, xib_parent, **kwargs)
            case class_name:
                print(f'Warning: Skipping unrecognized view class name {class_name}')

    def traverse_window(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB window and adds it to the XIB.'''

        assert obj.clazz.name == b'WindowTemplate', obj.clazz.name

        rect = self.convert_rect(obj.contents[0])
        title = obj.contents[1].values[4].decode()
        view = obj.contents[1].values[7]

        print(f'Adding window {title}')

        xib_window = self.xib.objects.add_object('window', title=title)
        # TODO: Should we add a canvas location?
        # xib_window.add('point', key='canvasLocation', x=rect['x'], y=rect['y'])
        xib_window.add('windowStyleMask', key='styleMask', titled='YES', closable='YES', miniaturizable='YES', resizable='YES')
        xib_window.add('rect', key='contentRect', **rect)

        self.traverse_view(view, xib_window, key='contentView')

    def traverse_group(self, group: typedstream.TypedGroup):
        '''Recursively traverses the given NIB group.'''

        if len(group.values) == 2 and group.values[1] == b'MainMenu':
            self.traverse_main_menu(group.values[0])
        else:
            for value in group.values:
                self.traverse_value(value)

    def traverse_object(self, obj: typedstream.GenericArchivedObject):
        '''Recursively traverses the given NIB object.'''

        self.visited_objects.add(obj)

        match obj.clazz.name.decode():
            case 'CustomObject':
                self.traverse_custom_object(obj)
            # NOTE: We rely on these connectors being listed after the relevant objects
            case 'IBControlConnector':
                self.traverse_control_connector(obj)
            case 'IBOutletConnector':
                self.traverse_outlet_connector(obj)
            case 'WindowTemplate':
                self.traverse_window(obj)

        for group in obj.contents:
            self.traverse_group(group)

    def traverse_list(self, list: typedstream.types.nextstep.List):
        '''Recursively traverses the given NIB list.'''

        for element in list.elements:
            self.traverse_value(element)

    def traverse_value(self, value: Any):
        '''Recursively traverses the given NIB value.'''

        if isinstance(value, typedstream.GenericArchivedObject) and value not in self.visited_objects:
            self.traverse_object(value)
        elif isinstance(value, typedstream.types.nextstep.List):
            self.traverse_list(value)

def convert_root(obj: typedstream.GenericArchivedObject, options: Options) -> XIB:
    converter = XIBConverter(options)
    converter.traverse_object(obj)
    return converter.xib

def main():
    parser = argparse.ArgumentParser(description='Converts a legacy NeXTStep NIB to XIB.')
    parser.add_argument('-o', '--output', required=True, type=Path, help='The path to the output XIB.')
    parser.add_argument('input', type=Path, help='The path to the input NIB.')

    args = parser.parse_args()
    options = Options()

    nib = typedstream.unarchive_from_file(args.input / 'data.nib')
    xib = convert_root(nib, options=options)

    xib.indent()
    xib.write(args.output)

if __name__ == '__main__':
    main()
