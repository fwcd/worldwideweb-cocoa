#!/usr/bin/env python3

# A small tool to convert a legacy NeXTStep NIB bundle to a modern Interface
# Builder XIB that recent versions of Xcode (e.g. 15.4) can read. Note that
# the tool cannot handle many of the newer versions of the NIB file format
# and is expressly built to handle the reverse engineered WorldWideWeb.nib

from dataclasses import dataclass, field
from pathlib import Path
from uuid import uuid4
from typing import Any, Iterable, Optional, Self

import argparse
import typedstream
import xml.etree.ElementTree as ET

class XIBNode:
    def __init__(self, element: ET.Element, id: Optional[str]=None):
        self.element = element
        self.id = id

        self._connections: Optional[Self] = None
        self._items: Optional[Self] = None

    def add_object(self, class_or_tag_name: str, id: Optional[str]=None, **kwargs) -> Self:
        '''Adds an object under this node.'''

        assert len(class_or_tag_name) > 0
        is_custom = class_or_tag_name[0].isupper()

        id = id or str(uuid4())
        child = ET.Element('customObject' if is_custom else class_or_tag_name, attrib={
            'id': id,
            **kwargs,
            **({'customClass': class_or_tag_name} if is_custom else {}),
        })
        self.element.append(child)

        return XIBNode(child, id)
    
    def add(self, tag_name: str, **kwargs) -> Self:
        '''Adds a custom node under this node.'''

        child = ET.Element(tag_name, attrib={**kwargs})
        self.element.append(child)

        return XIBNode(child)
    
    def add_menu_item(self, **kwargs) -> Self:
        '''Adds a menu item to this menu.'''

        items = self if self.element.tag == 'items' else self.items
        return items.add_object('menuItem', **kwargs)

    def add_submenu(self, **kwargs) -> Self:
        '''Adds a submenu to this menu.'''

        assert self.element.tag == 'menuItem', 'Can only add a submenu to a menu item'
        return self.add_object('menu', key='submenu', title=self.element.attrib['title'], **kwargs)

    @property
    def connections(self) -> Self:
        assert self.id is not None, 'Can only connect to an object with an id'
        if self._connections is None:
            self._connections = XIBNode(ET.Element('connections'))
            self.element.append(self._connections.element)
        return self._connections

    @property
    def items(self) -> Self:
        assert self.element.tag == 'menu', 'Can only fetch items on a menu (object)'
        if self._items is None:
            self._items = XIBNode(ET.Element('items'))
            self.element.append(self._items.element)
        return self._items

    def connect_outlet(self, property: str, destination: str | Self):
        '''Adds an outlet to the given destination.'''

        return self.connections.add_object('outlet',
            property=property,
            destination=destination if isinstance(destination, str) else destination.id,
        )
    
    def connect_action(self, selector: str, target: str | Self):
        '''Adds an action invoking the given target with the given selector.'''

        return self.connections.add_object('action',
            selector=selector,
            target=target if isinstance(target, str) else target.id,
        )
    
class XIB:
    def __init__(self):
        self.root = ET.Element('document', attrib={
            'type': 'com.apple.InterfaceBuilder3.Cocoa.XIB',
            'version': '3.0',
            'toolsVersion': '32700.99.1234',
            'targetRuntime': 'MacOSX.Cocoa',
            'propertyAccessControl': 'none',
            'useAutolayout': 'NO',
            'customObjectInstantiationMethod': 'direct',
        })

        self.tree = ET.ElementTree(self.root)
    
        self.dependencies = self.add_node('dependencies')
        self.dependencies.add('plugIn', identifier='com.apple.InterfaceBuilder.CocoaPlugin', version='22690')
        self.dependencies.add('capability', name='documents saved in the Xcode 8 format', minToolsVersion='8.0')

        self.objects = self.add_node('objects')

        # Add default objects
        files_owner = self.objects.add_object('NSApplication', id='-2', userLabel="File's Owner")
        first_responder = self.objects.add_object('FirstResponder', id='-1', userLabel='First Responder')
        self.objects.add_object('NSObject', id='-3', userLabel='Application')
        self.objects.add_object('NSFontManager')

        app_delegate = self.objects.add_object('AppDelegate')
        files_owner.connect_outlet('delegate', app_delegate)

        # Add main menu
        # TODO: Add other standard menu items, see Reference/MainMenu.xib
        main_menu = self.objects.add_object('menu', systemMenu='main')
        main_menu.add('point', key='canvasLocation', x='200', y='121')

        app_item = main_menu.add_menu_item(title='WorldWideWeb')
        app_menu = app_item.add_submenu(systemMenu='apple')
        app_menu.add_menu_item(title='About WorldWideWeb')
        app_menu.add_menu_item(isSeparatorItem='YES')
        quit_item = app_menu.add_menu_item(title='Quit WorldWideWeb', keyEquivalent='q')
        quit_item.connect_action('terminate:', first_responder)

        self.main_menu = main_menu
        self.app_menu = app_menu

        # Add window
        window = self.objects.add_object('window', title='WorldWideWeb')
        window.add('point', key='canvasLocation', x='200', y='400')
        window.add('windowStyleMask', key='styleMask', titled='YES', closable='YES', miniaturizable='YES', resizable='YES')
        window.add('rect', key='contentRect', x='0', y='0', width='480', height='360')
        window.add_object('view', key='contentView')
        window.connect_outlet('delegate', app_delegate)
        app_delegate.connect_outlet('window', window)

    def add_node(self, name: str) -> XIBNode:
        '''Creates a new node under the document root.'''

        element = ET.Element(name)
        self.root.append(element)
        return XIBNode(element)

    def indent(self, indent: str=' ' * 4):
        '''Indents the tree with the given indent (4 spaces by default).'''

        ET.indent(self.tree, space=indent)
    
    def write(self, path: Path):
        '''Writes the XIB to the given path.'''

        self.tree.write(path, encoding='utf-8', xml_declaration=True)

# TODO: Reverse-engineer the parameters of some common classes (e.g. View)
# TODO: Use a better order for "expanding" referenced objects (e.g. breadth-first)

@dataclass
class Options:
    pass

class XIBConverter:
    def __init__(self, options: Options):
        self.options = options
        self.xib = XIB()
        self.visited_objects: set[typedstream.GenericArchivedObject] = set()
    
    def convert_menu_cell(self, cell: typedstream.GenericArchivedObject, xib_menu: XIBNode, level: int):
        '''Traverses the given NIB menu cell and adds it to the given XIB menu.'''

        assert cell.clazz.name == b'MenuCell', cell.clazz.name

        title = cell.contents[0].values[0].decode()
        submenu = cell.contents[1].values[0]

        xib_item = xib_menu.add_menu_item(title=title)

        if isinstance(submenu, typedstream.GenericArchivedObject) and submenu.clazz.name == b'MenuTemplate':
            xib_submenu = xib_item.add_submenu()
            self.convert_menu(submenu, xib_submenu, level=level)
        else:
            print(f"{'  ' * level}{title}")

    def convert_menu(self, menu: typedstream.GenericArchivedObject, xib_menu: XIBNode, level: int=0):
        '''Traverses the given NIB menu and adds its cells to the given XIB menu.'''

        assert menu.clazz.name == b'MenuTemplate', menu.clazz.name

        title = menu.contents[2].values[0].decode()
        matrix = menu.contents[2].values[1]
        print(f"{'  ' * level}{title} @ {id(menu)}")
        assert isinstance(matrix, typedstream.GenericArchivedObject) and matrix.clazz.name == b'Matrix'

        matrix_list = matrix.contents[12].values[0]
        assert isinstance(matrix_list, typedstream.types.nextstep.List), type(matrix_list)

        for cell in matrix_list.elements:
            assert isinstance(cell, typedstream.GenericArchivedObject)
            self.convert_menu_cell(cell, xib_menu, level=level + 1)

    def traverse_main_menu(self, menu: typedstream.GenericArchivedObject):
        '''Traverses the given NIB main menu and adds its cells to the XIB main menu.'''

        self.convert_menu(menu, self.xib.main_menu)

    def traverse_group(self, group: typedstream.TypedGroup):
        '''Recursively traverses the given NIB group.'''

        if len(group.values) == 2 and group.values[1] == b'MainMenu':
            self.traverse_main_menu(group.values[0])
        else:
            for value in group.values:
                if isinstance(value, typedstream.GenericArchivedObject) and value not in self.visited_objects:
                    self.traverse_object(value)

    def traverse_object(self, obj: typedstream.GenericArchivedObject):
        '''Recursively traverses the given NIB object.'''

        self.visited_objects.add(obj)

        for group in obj.contents:
            self.traverse_group(group)

def convert_root(obj: typedstream.GenericArchivedObject, options: Options) -> XIB:
    converter = XIBConverter(options)
    converter.traverse_object(obj)
    return converter.xib

def main():
    parser = argparse.ArgumentParser(description='Converts a legacy NeXTStep NIB to XIB.')
    parser.add_argument('-o', '--output', required=True, type=Path, help='The path to the output XIB.')
    parser.add_argument('input', type=Path, help='The path to the input NIB.')

    args = parser.parse_args()
    options = Options()

    nib = typedstream.unarchive_from_file(args.input / 'data.nib')
    xib = convert_root(nib, options=options)

    xib.indent()
    xib.write(args.output)

if __name__ == '__main__':
    main()
