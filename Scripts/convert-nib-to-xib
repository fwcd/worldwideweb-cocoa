#!/usr/bin/env python3

# A small tool to convert a legacy NeXTStep NIB bundle to a modern Interface
# Builder XIB that recent versions of Xcode (e.g. 15.4) can read. Note that
# the tool cannot handle many of the newer versions of the NIB file format
# and is expressly built to handle the reverse engineered WorldWideWeb.nib

from dataclasses import dataclass, field
from pathlib import Path
from uuid import uuid4
from typing import Any, Iterable, Optional

import argparse
import typedstream
import xml.etree.ElementTree as ET

# TODO: Reverse-engineer the parameters of some common classes (e.g. View)
# TODO: Use a better order for "expanding" referenced objects (e.g. breadth-first)
# TODO: Generate a "modern" XIB and perhaps only keep the old one around as a reference

@dataclass
class Options:
    convert_class_names: bool

@dataclass
class State:
    options: Options
    visited_objects: set[typedstream.GenericArchivedObject] = field(default_factory=set)

def convert_class_name(c: str, state: State) -> str:
    if not state.options.convert_class_names or c.startswith('IB'):
        return c
    else:
        return f"NS{c.removeprefix('NX').removesuffix('Template')}"

def convert_value(value: Any, state: State) -> ET.Element:
    if value is None:
        return ET.Element('nil')
    elif isinstance(value, int):
        element = ET.Element('int')
        element.text = str(value)
        return element
    elif isinstance(value, float):
        element = ET.Element('float')
        element.text = str(value)
        return element
    elif isinstance(value, bytes):
        element = ET.Element('string')
        element.text = value.decode()
        return element
    elif isinstance(value, typedstream.Class):
        element = ET.Element(
            'class',
            attrib={
                'name': convert_class_name(value.name.decode(), state=state),
                **({'superclass': convert_class_name(value.superclass.name.decode(), state=state)} if value.superclass else {}),
            },
        )
        return element
    elif isinstance(value, typedstream.GenericArchivedObject):
        if value in state.visited_objects:
            return ET.Element(
                'reference',
                attrib={
                    'class': convert_class_name(value.clazz.name.decode(), state=state),
                    'ref': str(id(value)),
                },
            )
        state.visited_objects.add(value)

        return convert_object(value, name='obj', state=state)
    elif isinstance(value, typedstream.types.nextstep.List):
        element = ET.Element('list')
        for item in value.elements:
            element.append(convert_value(item, state=state))
        return element
    else:
        return ET.Element('unknown', attrib={'name': str(type(value))})

def convert_group(group: typedstream.TypedGroup, state: State) -> Iterable[ET.Element]:
    for value in group.values:
        yield convert_value(value, state=state)

def convert_object(obj: typedstream.GenericArchivedObject, name: str, state: State) -> ET.Element:
    element = ET.Element(
        name,
        attrib={
            'class': convert_class_name(obj.clazz.name.decode(), state=state),
            'id': str(id(obj))
        } if name == 'obj' else {},
    )

    for group in obj.contents:
        group_element = ET.SubElement(element, 'group')
        for value in convert_group(group, state=state):
            group_element.append(value)

    return element

class XIB:
    def __init__(self):
        self.root = ET.Element('document', attrib={
            'type': 'com.apple.InterfaceBuilder3.Cocoa.XIB',
            'version': '3.0',
            'toolsVersion': '32700.99.1234',
            'targetRuntime': 'MacOSX.Cocoa',
            'propertyAccessControl': 'none',
            'useAutolayout': 'NO',
            'customObjectInstantiationMethod': 'direct',
        })

        self.dependencies = ET.Element('dependencies')
        self.dependencies.append(ET.Element('plugIn', attrib={'identifier': 'com.apple.InterfaceBuilder.CocoaPlugin', 'version': '22690'}))
        self.dependencies.append(ET.Element('capability', attrib={'name': 'documents saved in the Xcode 8 format', 'minToolsVersion': '8.0'}))
        self.root.append(self.dependencies)

        self.objects = ET.Element('objects')
        self.root.append(self.objects)

        self.id_to_object: dict[str, ET.Element] = {}
        self.id_to_connections: dict[str, ET.Element] = {}

        # Add placeholders
        files_owner = self.add_object('NSApplication', id='-2', userLabel="File's Owner")
        self.add_object('FirstResponder', id='-1', userLabel='First Responder')
        self.add_object('NSObject', id='-3', userLabel='Application')

        # Add custom objects
        app_delegate = self.add_object('AppDelegate')
        self.connect(files_owner, 'delegate', app_delegate)
        self.add_object('NSFontManager')

        # Add window
        window = self.add_object('window', title='WorldWideWeb')
        self.connect(app_delegate, 'window', window)

        self.tree = ET.ElementTree(self.root)
    
    def add_object(self, name: str, id: Optional[str]=None, **kwargs) -> str:
        '''Adds an object of the given class.'''

        id = id or str(uuid4())

        assert len(name) > 0
        is_custom = name[0].isupper()

        obj = ET.Element('customObject' if is_custom else name, attrib={
            'id': id,
            **kwargs,
            **({'customClass': name} if is_custom else {}),
        })
        self.objects.append(obj)

        self.id_to_object[id] = obj

        return id

    def connect(self, src_id: str, property: str, dest_id: str) -> str:
        '''Adds an outlet to the given source referencing the given destination.'''

        id = str(uuid4())

        if src_id not in self.id_to_connections:
            conns = ET.Element('connections')
            obj = self.id_to_object[src_id]
            obj.append(conns)
            self.id_to_connections[src_id] = conns
        
        conns = self.id_to_connections[src_id]
        outlet = ET.Element('outlet', attrib={'property': property, 'id': id, 'destination': dest_id})
        conns.append(outlet)

        return id

    def indent(self, indent: str=' ' * 4):
        '''Indents the tree with the given indent (4 spaces by default).'''

        ET.indent(self.tree, space=indent)
    
    def write(self, path: Path):
        '''Writes the XIB to the given path.'''

        self.tree.write(path, encoding='utf-8', xml_declaration=True)

def convert_root(obj: typedstream.GenericArchivedObject, options: Options) -> XIB:
    # TODO
    # root.append(convert_object(obj, name='data', state=State(options=options)))

    xib = XIB()
    return xib

def main():
    parser = argparse.ArgumentParser(description='Converts a legacy NeXTStep NIB to XIB.')
    parser.add_argument('-o', '--output', required=True, type=Path, help='The path to the output XIB.')
    parser.add_argument('--convert-class-names', action=argparse.BooleanOptionalAction, default=True, help="Convert class names to Cocoa's NS prefix.")
    parser.add_argument('input', type=Path, help='The path to the input NIB.')

    args = parser.parse_args()
    options = Options(
        convert_class_names=args.convert_class_names,
    )

    nib = typedstream.unarchive_from_file(args.input / 'data.nib')
    xib = convert_root(nib, options=options)

    xib.indent()
    xib.write(args.output)

if __name__ == '__main__':
    main()
