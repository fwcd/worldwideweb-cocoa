#!/usr/bin/env python3

# A small tool to convert a legacy NeXTStep NIB bundle to a modern Interface
# Builder XIB that recent versions of Xcode (e.g. 15.4) can read. Note that
# the tool cannot handle many of the newer versions of the NIB file format
# and is expressly built to handle the reverse engineered WorldWideWeb.nib

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Iterable

import argparse
import typedstream
import xml.etree.ElementTree as ET

# TODO: Reverse-engineer the parameters of some common classes (e.g. View)
# TODO: Use a better order for "expanding" referenced objects (e.g. breadth-first)
# TODO: Generate a "modern" XIB and perhaps only keep the old one around as a reference

@dataclass
class Options:
    convert_class_names: bool

@dataclass
class State:
    options: Options
    visited_objects: set[typedstream.GenericArchivedObject] = field(default_factory=set)

def convert_class_name(c: str, state: State) -> str:
    if not state.options.convert_class_names or c.startswith('IB'):
        return c
    else:
        return f"NS{c.removeprefix('NX').removesuffix('Template')}"

def convert_value(value: Any, state: State) -> ET.Element:
    if value is None:
        return ET.Element('nil')
    elif isinstance(value, int):
        element = ET.Element('int')
        element.text = str(value)
        return element
    elif isinstance(value, float):
        element = ET.Element('float')
        element.text = str(value)
        return element
    elif isinstance(value, bytes):
        element = ET.Element('string')
        element.text = value.decode()
        return element
    elif isinstance(value, typedstream.Class):
        element = ET.Element(
            'class',
            attrib={
                'name': convert_class_name(value.name.decode(), state=state),
                **({'superclass': convert_class_name(value.superclass.name.decode(), state=state)} if value.superclass else {}),
            },
        )
        return element
    elif isinstance(value, typedstream.GenericArchivedObject):
        if value in state.visited_objects:
            return ET.Element(
                'reference',
                attrib={
                    'class': convert_class_name(value.clazz.name.decode(), state=state),
                    'ref': str(id(value)),
                },
            )
        state.visited_objects.add(value)

        return convert_object(value, name='object', state=state)
    elif isinstance(value, typedstream.types.nextstep.List):
        element = ET.Element('list')
        for item in value.elements:
            element.append(convert_value(item, state=state))
        return element
    else:
        return ET.Element('unknown', attrib={'name': str(type(value))})

def convert_group(group: typedstream.TypedGroup, state: State) -> Iterable[ET.Element]:
    for value in group.values:
        yield convert_value(value, state=state)

def convert_object(object: typedstream.GenericArchivedObject, name: str, state: State) -> ET.Element:
    element = ET.Element(
        name,
        attrib={
            'class': convert_class_name(object.clazz.name.decode(), state=state),
            'id': str(id(object))
        } if name == 'object' else {},
    )

    for group in object.contents:
        group_element = ET.SubElement(element, 'group')
        for value in convert_group(group, state=state):
            group_element.append(value)

    return element

class XIB:
    def __init__(self):
        self.root = ET.Element('document', attrib={
            'type': 'com.apple.InterfaceBuilder3.Cocoa.XIB',
            'version': '3.0',
            'toolsVersion': '32700.99.1234',
            'targetRuntime': 'MacOSX.Cocoa',
            'propertyAccessControl': 'none',
            'useAutolayout': 'NO',
            'customObjectInstantiationMethod': 'direct',
        })

        self.deps = ET.Element('dependencies')
        self.deps.append(ET.Element('plugIn', attrib={'identifier': 'com.apple.InterfaceBuilder.CocoaPlugin', 'version': '22690'}))
        self.deps.append(ET.Element('capability', attrib={'name': 'documents saved in the Xcode 8 format', 'minToolsVersion': '8.0'}))
        self.root.append(self.deps)

        self.objs = ET.Element('objects')

        self.objs.append(ET.Element('customObject', attrib={'id': '-1', 'userLabel': 'First Responder', 'customClass': 'FirstResponder'}))
        self.objs.append(ET.Element('customObject', attrib={'id': '-2', 'userLabel': "File's Owner", 'customClass': 'NSApplication'}))
        self.objs.append(ET.Element('customObject', attrib={'id': '-3', 'userLabel': 'Application', 'customClass': 'NSObject'}))

        window = ET.Element('window', attrib={'title': 'WorldWideWeb'})
        self.objs.append(window)

        self.root.append(self.objs)

        self.tree = ET.ElementTree(self.root)
    
    def indent(self, indent: str=' ' * 4):
        ET.indent(self.tree, space=indent)
    
    def write(self, path: Path):
        self.tree.write(path, encoding='utf-8', xml_declaration=True)

def convert_root(object: typedstream.GenericArchivedObject, options: Options) -> XIB:
    # TODO
    # root.append(convert_object(object, name='data', state=State(options=options)))

    xib = XIB()
    return xib

def main():
    parser = argparse.ArgumentParser(description='Converts a legacy NeXTStep NIB to XIB.')
    parser.add_argument('-o', '--output', required=True, type=Path, help='The path to the output XIB.')
    parser.add_argument('--convert-class-names', action=argparse.BooleanOptionalAction, default=True, help="Convert class names to Cocoa's NS prefix.")
    parser.add_argument('input', type=Path, help='The path to the input NIB.')

    args = parser.parse_args()
    options = Options(
        convert_class_names=args.convert_class_names,
    )

    nib = typedstream.unarchive_from_file(args.input / 'data.nib')
    xib = convert_root(nib, options=options)

    xib.indent()
    xib.write(args.output)

if __name__ == '__main__':
    main()
