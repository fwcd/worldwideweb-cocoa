#!/usr/bin/env python3

# A small tool to convert a legacy NeXTStep NIB bundle to a modern Interface
# Builder XIB that recent versions of Xcode (e.g. 15.4) can read. Note that
# the tool cannot handle many of the newer versions of the NIB file format
# and is expressly built to handle the reverse engineered WorldWideWeb.nib

from dataclasses import dataclass
from pathlib import Path
from uuid import uuid4
from typing import Any, Optional, Self

import argparse
import typedstream
import xml.etree.ElementTree as ET

next_object_id = 0

class XIBNode:
    def __init__(self, element: ET.Element, id: Optional[str]=None, custom_class: Optional[str]=None):
        self.element = element
        self.id = id
        self.custom_class = custom_class

        self._connections: Optional[Self] = None
        self._items: Optional[Self] = None
        self._subviews: Optional[Self] = None

    def add_object(self, class_or_tag_name: str, id: Optional[str]=None, **kwargs) -> Self:
        '''Adds an object under this node.'''

        assert len(class_or_tag_name) > 0
        is_custom = class_or_tag_name[0].isupper()

        if not id:
            global next_object_id
            id = str(next_object_id)
            next_object_id += 1

        child = ET.Element('customObject' if is_custom else class_or_tag_name, attrib={
            'id': id,
            **kwargs,
            **({'customClass': class_or_tag_name} if is_custom else {}),
        })
        self.element.append(child)

        return XIBNode(child, id=id, custom_class=class_or_tag_name if is_custom else None)
    
    def add(self, tag_name: str, **kwargs) -> Self:
        '''Adds a custom node under this node.'''

        child = ET.Element(tag_name, attrib={**kwargs})
        self.element.append(child)

        return XIBNode(child)
    
    def add_menu_item(self, **kwargs) -> Self:
        '''Adds a menu item to this menu.'''

        items = self if self.element.tag == 'items' else self.items
        return items.add_object('menuItem', **kwargs)

    def add_submenu(self, **kwargs) -> Self:
        '''Adds a submenu to this menu.'''

        assert self.element.tag == 'menuItem', 'Can only add a submenu to a menu item'
        return self.add_object('menu', key='submenu', title=self.element.attrib['title'], **kwargs)
    
    def __str__(self):
        return self.custom_class or self.element.tag

    @property
    def connections(self) -> Self:
        assert self.id is not None, 'Can only connect to an object with an id'
        if self._connections is None:
            self._connections = XIBNode(ET.Element('connections'))
            self.element.append(self._connections.element)
        return self._connections

    @property
    def items(self) -> Self:
        assert self.element.tag == 'menu', 'Can only fetch items on a menu (object)'
        if self._items is None:
            self._items = XIBNode(ET.Element('items'))
            self.element.append(self._items.element)
        return self._items

    @property
    def subviews(self) -> Self:
        if self._subviews is None:
            self._subviews = XIBNode(ET.Element('subviews'))
            self.element.append(self._subviews.element)
        return self._subviews

    def connect_outlet(self, property: str, destination: str | Self):
        '''Adds an outlet to the given destination.'''

        return self.connections.add_object('outlet',
            property=property,
            destination=destination if isinstance(destination, str) else destination.id,
        )
    
    def connect_action(self, selector: str, target: str | Self):
        '''Adds an action invoking the given target with the given selector.'''

        return self.connections.add_object('action',
            selector=selector,
            target=target if isinstance(target, str) else target.id,
        )
    
class XIB:
    def __init__(self):
        self.root = ET.Element('document', attrib={
            'type': 'com.apple.InterfaceBuilder3.Cocoa.XIB',
            'version': '3.0',
            'toolsVersion': '32700.99.1234',
            'targetRuntime': 'MacOSX.Cocoa',
            'propertyAccessControl': 'none',
            'useAutolayout': 'NO',
            'customObjectInstantiationMethod': 'direct',
        })

        self.tree = ET.ElementTree(self.root)
    
        self.dependencies = self.add_node('dependencies')
        self.dependencies.add('plugIn', identifier='com.apple.InterfaceBuilder.CocoaPlugin', version='22690')
        self.dependencies.add('capability', name='documents saved in the Xcode 8 format', minToolsVersion='8.0')

        self.objects = self.add_node('objects')

        # Add default objects
        self.files_owner = self.objects.add_object('NSApplication', id='-2', userLabel="File's Owner")
        self.first_responder = self.objects.add_object('FirstResponder', id='-1', userLabel='First Responder')
        self.objects.add_object('NSObject', id='-3', userLabel='Application')
        self.font_manager = self.objects.add_object('NSFontManager')

        # Add main menu
        # TODO: Add other standard menu items, see Reference/MainMenu.xib
        main_menu = self.objects.add_object('menu', systemMenu='main')
        main_menu.add('point', key='canvasLocation', x='200', y='121')

        app_item = main_menu.add_menu_item(title='WorldWideWeb')
        app_menu = app_item.add_submenu(systemMenu='apple')
        app_menu.add_menu_item(title='About WorldWideWeb')
        app_menu.add_menu_item(isSeparatorItem='YES')

        self.main_menu = main_menu
        self.app_menu = app_menu

    def add_node(self, name: str) -> XIBNode:
        '''Creates a new node under the document root.'''

        element = ET.Element(name)
        self.root.append(element)
        return XIBNode(element)

    def indent(self, indent: str=' ' * 4):
        '''Indents the tree with the given indent (4 spaces by default).'''

        ET.indent(self.tree, space=indent)
    
    def write(self, path: Path):
        '''Writes the XIB to the given path.'''

        self.tree.write(path, encoding='utf-8', xml_declaration=True)

# TODO: Reverse-engineer the parameters of some common classes (e.g. View)
# TODO: Use a better order for "expanding" referenced objects (e.g. breadth-first)

@dataclass
class Options:
    pass

class XIBConverter:
    def __init__(self, options: Options):
        self.options = options
        self.xib = XIB()

        self.visited_objects: set[typedstream.GenericArchivedObject] = set()
        self.object_to_xib_node: dict[typedstream.GenericArchivedObject, XIBNode] = {}
    
    def traverse_menu_cell(self, cell: typedstream.GenericArchivedObject, xib_menu: XIBNode, level: int):
        '''Traverses the given NIB menu cell and adds it to the given XIB menu.'''

        assert cell.clazz.name == b'MenuCell', cell.clazz.name

        # Parse basic metadata
        title = cell.contents[0].values[0].decode()

        xib_properties = {}

        # Parse the key equivalent/keyboard shortcut
        shortcut_info = cell.contents[4]
        if len(shortcut_info.values) == 4 and isinstance(shortcut_info.values[3], int):
            key_equivalent = shortcut_info.values[3] >> 8
            if key_equivalent > 0:
                xib_properties['keyEquivalent'] = chr(key_equivalent)

        # Parse the submenu
        submenu = cell.contents[1].values[0]
        has_submenu = isinstance(submenu, typedstream.GenericArchivedObject) and submenu.clazz.name == b'MenuTemplate'

        # Avoid adding menu items or special menus (e.g. Services) to the menu
        # bar directly to match the macOS conventions.
        if (not has_submenu or title in {'Services'}) and xib_menu == self.xib.main_menu:
            xib_item = self.xib.app_menu.add_menu_item(title=title, **xib_properties)
        else:
            xib_item = xib_menu.add_menu_item(title=title, **xib_properties)
        
        self.object_to_xib_node[cell] = xib_item

        if has_submenu:
            xib_submenu = xib_item.add_submenu()
            self.traverse_menu(submenu, xib_submenu, level=level)
        else:
            print(f"{'  ' * level}{title}")

    def traverse_menu(self, menu: typedstream.GenericArchivedObject, xib_menu: XIBNode, level: int=0):
        '''Traverses the given NIB menu and adds its cells to the given XIB menu.'''

        assert menu.clazz.name == b'MenuTemplate', menu.clazz.name

        # TODO: Should we do `self.object_to_xib_node[cell] = menu` here?
        # We probably don't need this since there don't seem to be any control connectors.

        # Parse basic metadata
        title = menu.contents[2].values[0].decode()

        # Output an indented short description for debugging
        print(f"{'  ' * level}{title} @ {id(menu)}")

        # Parse the matrix
        matrix = menu.contents[2].values[1]
        assert isinstance(matrix, typedstream.GenericArchivedObject) and matrix.clazz.name == b'Matrix'

        # Parse the list holding the cells from the matrix
        matrix_list = matrix.contents[12].values[0]
        assert isinstance(matrix_list, typedstream.types.nextstep.List), type(matrix_list)

        # Convert the menu cells to XIB items
        for cell in matrix_list.elements:
            assert isinstance(cell, typedstream.GenericArchivedObject)
            self.traverse_menu_cell(cell, xib_menu, level=level + 1)

    def traverse_main_menu(self, menu: typedstream.GenericArchivedObject):
        '''Traverses the given NIB main menu and adds its cells to the XIB main menu.'''

        self.traverse_menu(menu, self.xib.main_menu)

    def traverse_custom_object(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB custom object and adds it to the XIB.'''

        assert obj.clazz.name == b'CustomObject', obj.clazz.name

        custom_class = obj.contents[0].values[0].decode()
        match custom_class:
            case 'Application':
                self.object_to_xib_node[obj] = self.xib.files_owner
            case 'FontManager':
                self.object_to_xib_node[obj] = self.xib.font_manager
            case _:
                print(f'Adding custom object {custom_class}')
                self.object_to_xib_node[obj] = self.xib.objects.add_object(custom_class)

    def traverse_control_connector(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB control connector and adds it to the XIB.'''

        assert obj.clazz.name == b'IBControlConnector', obj.clazz.name

        group = obj.contents[0]
        src_obj = group.values[0]
        dest_obj = group.values[1]
        selector = group.values[2].decode()

        # Not sure why this can happen, but apparently it can
        if dest_obj is None:
            return

        if src_xib_node := self.object_to_xib_node.get(src_obj):
            if dest_xib_node := self.object_to_xib_node.get(dest_obj):
                print(f'Connecting {src_xib_node} to {selector} on {dest_xib_node} (action)')
                src_xib_node.connect_action(
                    selector=selector,
                    target=dest_xib_node,
                )
            else:
                print(f'Warning: Could not connect action due to untranslated destination object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')
        else:
            print(f'Warning: Could not connect action due to untranslated source object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')

    def traverse_outlet_connector(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB outlet connector and adds it to the XIB.'''

        assert obj.clazz.name == b'IBOutletConnector', obj.clazz.name

        group = obj.contents[0]
        src_obj = group.values[0]
        dest_obj = group.values[1]
        property = group.values[2].decode()

        if src_xib_node := self.object_to_xib_node.get(src_obj):
            if dest_xib_node := self.object_to_xib_node.get(dest_obj):
                print(f"Connecting {src_xib_node}'s {property} to {dest_xib_node} (outlet)")
                src_xib_node.connect_outlet(
                    property=property,
                    destination=dest_xib_node,
                )
            else:
                print(f'Warning: Could not connect outlet due to untranslated destination object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')
        else:
            print(f'Warning: Could not connect outlet due to untranslated source object ({src_obj.clazz.name.decode()} and {dest_obj.clazz.name.decode()})')

    def convert_rect(self, group: typedstream.TypedGroup) -> dict[str, str]:
        return {
            'x': str(group.values[0]),
            'y': str(group.values[1]),
            'width': str(group.values[2]),
            'height': str(group.values[3]),
        }
    
    # TODO: Abstract over more commonalities between the different view types

    def traverse_view(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        '''Traverses the given NIB view and adds it to the XIB.'''
        
        assert obj.clazz.name == b'View', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        children = obj.contents[6].values[0]

        xib_view = xib_parent.add_object('view', **kwargs)
        xib_view.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_view

        if children is not None:
            assert isinstance(children, typedstream.types.nextstep.List)
            for child in children.elements:
                assert isinstance(child, typedstream.GenericArchivedObject), type(child)
                self.traverse_any_view(child, xib_view.subviews)

    def traverse_box(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode):
        '''Traverses the given NIB box and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Box', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        children = obj.contents[6].values[0]

        xib_box = xib_parent.add_object('box')
        xib_box.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_box

        assert isinstance(children, typedstream.types.nextstep.List)
        content_view = children.elements[0]
        self.traverse_view(content_view, xib_box, key='contentView')

    def traverse_button_cell(self, obj: typedstream.GenericArchivedObject, xib_button: XIBNode):
        '''Traverses the given NIB button cell and adds it to the XIB.'''
        
        assert obj.clazz.name == b'ButtonCell', obj.clazz.name

        title = obj.contents[0].values[0].decode()

        # TODO: Figure out a cleaner looking button style that preserves the intended look and feel
        xib_cell = xib_button.add('buttonCell',
            key='cell',
            title=title,
            type='square',
            bezelStyle='shadowlessSquare',
            borderStyle='border',
            alignment='center',
        )
        self.object_to_xib_node[obj] = xib_cell

    def traverse_button(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode):
        '''Traverses the given NIB button and adds it to the XIB.'''
        
        assert obj.clazz.name == b'Button', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        cell = obj.contents[7].values[1]

        xib_button = xib_parent.add_object('button')
        xib_button.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_button

        self.traverse_button_cell(cell, xib_button)
    
    def traverse_text_field_cell(self, obj: typedstream.GenericArchivedObject, xib_text_field: XIBNode):
        '''Traverses the given NIB text field cell and adds it to the XIB.'''
        
        assert obj.clazz.name == b'TextFieldCell', obj.clazz.name

        title = obj.contents[0].values[0].decode()

        # TODO: Figure out a cleaner looking button style that preserves the intended look and feel
        xib_cell = xib_text_field.add('textFieldCell',
            key='cell',
            title=title,
        )
        self.object_to_xib_node[obj] = xib_cell

    def traverse_text_field(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode):
        '''Traverses the given NIB text field and adds it to the XIB.'''
        
        assert obj.clazz.name == b'TextField', obj.clazz.name

        frame = self.convert_rect(obj.contents[2])
        cell = obj.contents[7].values[1]

        xib_text_field = xib_parent.add_object('textField')
        xib_text_field.add('rect', key='frame', **frame)
        self.object_to_xib_node[obj] = xib_text_field

        self.traverse_text_field_cell(cell, xib_text_field)

    def traverse_any_view(self, obj: typedstream.GenericArchivedObject, xib_parent: XIBNode, **kwargs):
        match obj.clazz.name.decode():
            case 'View':
                self.traverse_view(obj, xib_parent, **kwargs)
            case 'Box':
                self.traverse_box(obj, xib_parent, **kwargs)
            case 'Button':
                self.traverse_button(obj, xib_parent, **kwargs)
            case 'TextField':
                self.traverse_text_field(obj, xib_parent, **kwargs)
            case class_name:
                print(f'Warning: Skipping unrecognized view class name {class_name}')

    def traverse_window(self, obj: typedstream.GenericArchivedObject):
        '''Traverses the given NIB window and adds it to the XIB.'''

        assert obj.clazz.name == b'WindowTemplate', obj.clazz.name

        rect = self.convert_rect(obj.contents[0])
        title = obj.contents[1].values[4].decode()
        view = obj.contents[1].values[7]

        print(f'Adding window {title}')

        xib_window = self.xib.objects.add_object('window', title=title)
        # TODO: Should we add a canvas location?
        # xib_window.add('point', key='canvasLocation', x=rect['x'], y=rect['y'])
        xib_window.add('windowStyleMask', key='styleMask', titled='YES', closable='YES', miniaturizable='YES', resizable='YES')
        xib_window.add('rect', key='contentRect', **rect)

        self.traverse_view(view, xib_window, key='contentView')

    def traverse_group(self, group: typedstream.TypedGroup):
        '''Recursively traverses the given NIB group.'''

        if len(group.values) == 2 and group.values[1] == b'MainMenu':
            self.traverse_main_menu(group.values[0])
        else:
            for value in group.values:
                self.traverse_value(value)

    def traverse_object(self, obj: typedstream.GenericArchivedObject):
        '''Recursively traverses the given NIB object.'''

        self.visited_objects.add(obj)

        match obj.clazz.name.decode():
            case 'CustomObject':
                self.traverse_custom_object(obj)
            # NOTE: We rely on these connectors being listed after the relevant objects
            case 'IBControlConnector':
                self.traverse_control_connector(obj)
            case 'IBOutletConnector':
                self.traverse_outlet_connector(obj)
            case 'WindowTemplate':
                self.traverse_window(obj)

        for group in obj.contents:
            self.traverse_group(group)

    def traverse_list(self, list: typedstream.types.nextstep.List):
        '''Recursively traverses the given NIB list.'''

        for element in list.elements:
            self.traverse_value(element)

    def traverse_value(self, value: Any):
        '''Recursively traverses the given NIB value.'''

        if isinstance(value, typedstream.GenericArchivedObject) and value not in self.visited_objects:
            self.traverse_object(value)
        elif isinstance(value, typedstream.types.nextstep.List):
            self.traverse_list(value)

def convert_root(obj: typedstream.GenericArchivedObject, options: Options) -> XIB:
    converter = XIBConverter(options)
    converter.traverse_object(obj)
    return converter.xib

def main():
    parser = argparse.ArgumentParser(description='Converts a legacy NeXTStep NIB to XIB.')
    parser.add_argument('-o', '--output', required=True, type=Path, help='The path to the output XIB.')
    parser.add_argument('input', type=Path, help='The path to the input NIB.')

    args = parser.parse_args()
    options = Options()

    nib = typedstream.unarchive_from_file(args.input / 'data.nib')
    xib = convert_root(nib, options=options)

    xib.indent()
    xib.write(args.output)

if __name__ == '__main__':
    main()
